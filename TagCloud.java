import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

/**
 * Tag Cloud Generator program counting the words and generate in tag cloud
 * using Java component
 *
 * @author Chuwen Sun, Xinyi Wei
 */

public final class TagCloud {

    /**
     * Default constructor--private to prevent instantiation.
     */
    private TagCloud() {
        // no code needed here
    }
    
    private static final String SEPARATORS = " \t\n\r,-=_~`.*&!^%$#@?"
            + "'|;:/<>()[]{}\"\'";
    /**
     * The maximum font size.
     */
    private static final int MAX_FONT_SIZE = 48;
    /**
     * The minimum font size.
     */
    private static final int MIN_FONT_SIZE = 11;
    /* 
     * Map Key comparetor
     */
    private static class StringLT implements Comparator<Map.Entry<String, Integer>> {
    	@Override
        public int compare(Map.Entry<String, Integer> p1, Map.Entry<String, Integer> p2) {
    		if (p1.getKey().equals(p2.getKey())) {
    		      return 0;
    		    }
            return p1.getKey().compareTo(p2.getKey());
        }
    }
    /*
     * Map value comparetor
     */
    private static class IntegerLT implements Comparator<Map.Entry<String, Integer>> {
        @Override
        public int compare(Map.Entry<String, Integer> p1, Map.Entry<String, Integer> p2) {
    		if (p1.getValue().equals(p2.getValue())) {
  		      return 0;
  		    }
            return p2.getValue().compareTo(p1.getValue());
        }
    }
    
    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param pos
     *            the starting index
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    private static String nextWordOrSeparator(String text, int pos) {
        assert text != null : "Violation of: text is not null";
        assert 0 <= pos : "Violation of: 0 <= position";
        assert pos < text.length() : "Violation of: position < |text|";

        int cursor = pos;
        boolean check = (SEPARATORS.contains(text.substring(pos, pos + 1)));
        while (cursor < text.length() && check == (SEPARATORS.contains(text.substring(cursor, cursor + 1)))) {
            cursor++;
        }
        return text.substring(pos, cursor);
    }
    
    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * 
     * <html> <head> <title>Top " + n +" words in data/importance.txt</title> 
     * <link href=\"http://web.cse.ohio-state.edu/software/2231/web-sw2/"
        		+ "assignments/projects/tag-cloud-generator/data/tagcloud.css\" "
        		+ "rel=\"stylesheet\" type=\"text/css\">
     * </head> 
     * <body>
     * <h2>Top " + n + " words in data/importance.txt</h2>
     * <hr>
     * <div class="cdiv">
     * <p class="cbox">
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputIndexHeader(PrintWriter out, int N, String input) {
        assert out != null : "Violation of: out is not null";
        out.println("<html>");
        out.println("<head>");
        out.println("<title>Top " + N + " words in " + input + "</title>");
        out.println("<link href=\"http://web.cse.ohio-state.edu/software/2231/web-sw2/assignments/projects/tag-cloud-generator/data/tagcloud.css\" rel=\"stylesheet\" type=\"text/css\">");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>Top " + N + " words in " + input + "</h2>");
        out.println("<hr>");
        out.println("<div class=\"cdiv\">");
        out.println("<p class=\"cbox\">");
    }
    
    

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </p>
     * </div>
     * </body>
     * </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     *
     */
    private static void outputIndexFooter(PrintWriter out) {
        assert out != null : "Violation of: out is not null";

        out.println("</p>");
        out.println("</div>");
        out.println("</body>");
        out.println("</html>");
    }
    
    /**
     * Calculates the font size for one word and outputs one line for one word in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <span style="cursor:default" class="(font)" title="count: (count)">a</span>
     *
     * @param out
     *            the output stream
     * 
     * @param max
     *            the max integer of occurence among top N words
     * @param min
     *            the min integer of occurence among top N words
     * @param pair  
     *          the pair contains one word and the number of its occurence in the text
     *          
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     *
     */
    private static void outputOneWord(PrintWriter out, int max, int min, Map.Entry<String, Integer> pair) {
        assert out != null : "Violation of: out is not null";
        
        int font;
        if(max != min) {
        	font = MIN_FONT_SIZE + (pair.getValue() - min) * (MAX_FONT_SIZE - MIN_FONT_SIZE) / (max - min);
        }else {
        	font = 28;
        }
        out.println("<span style=\"cursor:default\" class=\"f" + font + "\" title=\"count: " + pair.getValue() + "\">" + pair.getKey() +"</span>");        	
    }
    
    /**
     * put chart's keys in a queue
     *
     * @param chart
     *            The Map of word and it number of occurrence
     * @return The with all keys in Map.
     */
    private static PriorityQueue<Map.Entry<String, Integer>> mapToPQueueForDecreasingOrder(Map<String, Integer> chart, Comparator<Map.Entry<String, Integer>> order) {
    	PriorityQueue<Map.Entry<String, Integer>> out = new PriorityQueue<Map.Entry<String, Integer>>(chart.size(), order);
        for (Map.Entry<String,Integer> entry : chart.entrySet()) {  
            out.add(entry);
    } 
        return out;
    }
    
   
    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
    	 Scanner in = new Scanner(System.in);
        /*
         * Creates the comparators for the decreasing integer order and for the alphbetical order 
         */
        Comparator<Map.Entry<String, Integer>> sCompare = new StringLT();
        Comparator<Map.Entry<String, Integer>> iCompare = new IntegerLT();
        /*
         * Ask the user for the name of the input file and set the simplereader
         */
        System.out.print("Enter the input File name: ");
        String file = in.nextLine();
        Map<String, Integer> chart = new HashMap<String, Integer>();
        
        BufferedReader fileIn = null;
        
        //check fileIn is or not null
        try {
        	fileIn = new BufferedReader(new FileReader(file));
        } catch (FileNotFoundException e1) {
            System.err
                    .println("Error producing reader of input file (file not found)");
        }
        
        /*
         * create map for words and the count of the word
         */
        String str;
		try {
			str = fileIn.readLine();
	        while(str != null) {
	        	int cursor = 0;
	        	while(cursor < str.length()) {
	        		String word = nextWordOrSeparator(str, cursor);
	        		if(SEPARATORS.indexOf(word.charAt(0)) < 0) {
	        			word = word.toLowerCase();
	        			if(chart.containsKey(word)) {
	        				int count = chart.get(word);
	        				chart.replace(word, count + 1);       				
	        			}else {
	        				chart.put(word, 1);
	        			}
	        		}
	        		cursor += word.length();
	        	}
	        	str = fileIn.readLine();
	        }
		} catch (IOException e2) {
			System.err.println("Error in reading file");
		}
        try {
			fileIn.close();
		} catch (IOException e1) {
			System.err.println("Error in closing File input stream");
		}
        /*
         * Create a ProprityQueue for the decreasingOrder of wordCounts
         */
        PriorityQueue<Map.Entry<String, Integer>> decreasingOrder = mapToPQueueForDecreasingOrder(chart, iCompare);
        /*
         * Ask the user for the number of words they wanna see in the html
         */
        System.out.print("Enter the number of words to be included in the generated tag cloud: ");
        int N = Integer.parseInt(in.nextLine());        
        while(N < 0) {
        	System.out.println("Your number of words to be included in the generated tag cloud need to be a postive integer or zero!");
        	System.out.print("Please enter again: ");
        	N = Integer.parseInt(in.nextLine());
        }
            PriorityQueue<Map.Entry<String, Integer>> topN = new PriorityQueue<Map.Entry<String, Integer>>(N + 1, iCompare);
            for(int i = 0; i < N; i++) {
            	topN.add(decreasingOrder.poll());
            } 
        /*
         * Create a ProprityQueue for the alphbetical order for the top N words
         */

        /*
         * Ask the user for the output file name
         */
        System.out.print("Enter the output file name: ");
        String save = in.nextLine();
        PrintWriter nameSave;
        // check the nameSave        	
		try {
			nameSave = new PrintWriter(new BufferedWriter(new FileWriter(save)));
	        outputIndexHeader(nameSave, N, file);
	        if(N != 0) {
	        	int max = topN.element().getValue();
		        int min = max;
		        Iterator<Map.Entry<String, Integer>> it = topN.iterator();  
		        PriorityQueue<Map.Entry<String, Integer>> alphaOrder = new PriorityQueue<Map.Entry<String, Integer>>(N, sCompare);
		        while(it.hasNext()) {
		        	Map.Entry<String, Integer> en = it.next();
		        	min = en.getValue();
		        	alphaOrder.add(en);
		        }
		        /*
		         * output the rest of the html
		         */
		        for(int i = 0; i < N; i++) {
		        	outputOneWord(nameSave, max, min, alphaOrder.poll());
		        }
	        }	        
	        outputIndexFooter(nameSave);
	        nameSave.close();
		} catch (IOException e) {
			System.err.println("Error output filename");
		}
        in.close();
    }
}
